{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       Andrii Bessarab                                              \n//    Created:      Nov. 4, 2025                                                    \n//    Description:  Gets info from. web server, finds appropriate solution on SD card file, and controls robot.\n//                                                                            \n//----------------------------------------------------------------------------\n\n// --- Info ---\n// SCANNED STATE\n// Index = (FaceIndex * 5) + StickerIndex\n// Faces: U=0, F=1, R=2, B=3, L=4, D=5\n// Stickers: C=0, TL=1, TR=2, BR=3, BL=4\n\n#include \"iq_cpp.h\"\n#include <vector>\n#include <unordered_map>\n#include <string>\n#include <algorithm>\n\nusing namespace vex;\n\n/////////////////////////////// DEFINITIONS ///////////////////////////////\n// --- Skewb State Representation ---\nenum CENTER { W, G, O, B, R, Y };\nenum CORNER { UFL, UBL, UBR, UFR, DFL, DBL, DBR, DFR };\nstruct skewb_state\n{\n  std::vector<CENTER> center_colors;\n  std::vector<CORNER> corner_permutations;\n  std::unordered_map<CORNER, int> corner_orientations;\n};\n\n// --- Constants ---\nconst int MAX_BUFFER_SIZE = 100; \nconst std::vector<std::array<int, 3>> corners = {\n  {3, 7, 11},    // 0: UFR\n  {4, 6, 22},    // 1: UFL\n  {2, 16, 12},   // 2: UBR\n  {1, 17, 21},   // 3: UBL\n  {27, 8, 14},   // 4: DFR\n  {26, 9, 23},   // 5: DFL\n  {28, 19, 13},  // 6: DBR\n  {29, 18, 24}   // 7: DBL\n};\nstd::unordered_map<int, int> indexes_map = {\n  {0, 0},\n  {1, 1},\n  {2, 3},\n  {3, 2},\n  {4, 4},\n  {5, 5},\n  {6, 7},\n  {7, 6}\n};\n// Helper maps for conversion b/w scanned state and needed cpp struct\nstd::unordered_map<char, CENTER> char_to_center = {\n  {'W', W}, {'G', G}, {'O', O}, {'B', B}, {'R', R}, {'Y', Y}\n};\nstd::unordered_map<std::string, CORNER> colors_to_corner = {\n  {\"GRW\", UFR}, // W,R,G\n  {\"GOW\", UFL}, // W,G,O\n  {\"BRW\", UBR}, // W,B,R\n  {\"BOW\", UBL}, // W,O,B\n  {\"GRY\", DFR}, // Y,G,R\n  {\"GOY\", DFL}, // Y,O,G\n  {\"BRY\", DBR}, // Y,R,B\n  {\"BOY\", DBL}  // Y,B,O\n};\n\n// --- Function Prototypes ---\nvoid print_status(std::string status);\nstd::string get_state_from_serial();\nstd::string normalize_state(std::string state);\nskewb_state convert_state_to_struct(const std::string& state);\nstd::string skewb_state_to_string(const skewb_state& state);\n\n\n/////////////////////////////// MAIN PROGRAM ///////////////////////////////\nint main()\n{\n  // Initializing Robot Configuration\n  vexcodeInit();\n\n  print_status(\"Awaiting state...\");\n\n  // Get state from serial\n  std::string raw_state_string = get_state_from_serial();\n\n  print_status(\"Processing...\");\n\n  // Process state\n  std::string normalized_state_string = normalize_state(raw_state_string);\n  skewb_state state_struct = convert_state_to_struct(normalized_state_string);\n  std::string state_struct_stringified = skewb_state_to_string(state_struct);\n  printf(\"\\n%s\\n\", state_struct_stringified.c_str());\n\n  print_status(\"Thinking...\");\n  \n  // Obtain solution\n\n  print_status(\"Ready!\");\n\n  // Wait for touch to start solve\n\n  // Check sensory data\n\n  // Solve\n\n  // End the program\n  Brain.programStop();\n}\n\n\n/////////////////////////////// FUNCTIONS ///////////////////////////////\n// ---------- General ----------\n// Pritn status to brain screen\nvoid print_status(std::string status)\n{\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n  Brain.Screen.print(status.c_str());\n}\n\n// ---------- Robot Operations ----------\n// TODO\n\n// ---------- State Conversion ----------\n// Get skewb state from serial\nstd::string get_state_from_serial()\n{\n  char buffer[MAX_BUFFER_SIZE];\n\n  while (true)\n  {\n    if (fgets(buffer, MAX_BUFFER_SIZE, stdin) != NULL)\n    {\n      buffer[strcspn(buffer, \"\\n\\r\")] = '\\0';\n      if (strlen(buffer) > 0)\n        return std::string(buffer);\n    }\n    wait(20, msec);\n  }\n}\n\n// Find pos. of WGR corner on scanned config\nint get_position_of_inertial_corner(const std::string& state)\n{\n  // Check all 8 corners\n  for (int i = 0; i < corners.size(); ++i)\n  {\n    // Sort them alphabetically and check if\n    // the corner has all three colours.\n    const std::array<int, 3>& corner_indices = corners[i];\n\n    // Access the std::string using the [] operator, \n    // which works just like accessing a char array.\n    char c1 = state[corner_indices[0]];\n    char c2 = state[corner_indices[1]];\n    char c3 = state[corner_indices[2]];\n\n    std::array<char, 3> chars = {c1, c2, c3};\n    std::sort(chars.begin(), chars.end());\n\n    if (chars[0] == 'G' && chars[1] == 'R' && chars[2] == 'W')\n      return i;\n  }\n\n  return -1;\n}\n\n// Find orient. of WGR corner on scanned config\nint get_orientation_of_inertial_corner(const std::string& state, int pos)\n{\n  const std::array<int, 3>& indices = corners[pos];\n\n  // Check which of the 3 stickers is W\n  if (state[indices[0]] == 'W')\n    return 0;  // Up\n  else if (state[indices[1]] == 'W')\n    return 1;  // Front\n  else\n    return 2;  // Right\n}\n\n// State Y rotation\n// F -> R -> B -> L -> F\nstd::string state_rotate_y(std::string state)\n{\n  std::string new_state = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n\n  new_state[0] = state[0];\n  new_state[1] = state[2];\n  new_state[2] = state[3];\n  new_state[3] = state[4];\n  new_state[4] = state[1];\n  new_state[25] = state[25];\n  new_state[26] = state[29];\n  new_state[27] = state[26];\n  new_state[28] = state[27];\n  new_state[29] = state[28];\n\n  for(int i=0; i<5; ++i)\n  {\n    new_state[5+i] = state[20+i];\n    new_state[10+i] = state[5+i];\n    new_state[15+i] = state[10+i];\n    new_state[20+i] = state[15+i];\n  }\n  \n  return new_state;\n}\n\n// State X rotation\n// U -> F -> D -> B -> U\nstd::string state_rotate_x(std::string state)\n{\n  std::string new_state = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n\n  new_state[0] = state[15];\n  new_state[1] = state[18];\n  new_state[2] = state[19];\n  new_state[3] = state[16];\n  new_state[4] = state[17];\n  new_state[10] = state[10];\n  new_state[11] = state[12];\n  new_state[12] = state[13];\n  new_state[13] = state[14];\n  new_state[14] = state[11];\n  new_state[15] = state[25];\n  new_state[16] = state[28];\n  new_state[17] = state[29];\n  new_state[18] = state[26];\n  new_state[19] = state[27];\n  new_state[20] = state[20];\n  new_state[21] = state[24];\n  new_state[22] = state[21];\n  new_state[23] = state[22];\n  new_state[24] = state[23];\n\n  for(int i=0; i<5; ++i)\n  {\n    new_state[5+i] = state[0+i];\n    new_state[25+i] = state[5+i];\n  }\n\n  return new_state;\n}\n\n// Normalize scanned state\n// meaning modify string so that white-red-green corner\n// appears to be at front-right-top with white up\nstd::string normalize_state(std::string state)\n{\n  int inert_corner_pos = get_position_of_inertial_corner(state);\n  \n  // if inert corner at the bottom, put it up top\n  if (inert_corner_pos >= 4)\n  {\n    printf(\"Must rotate twice to move corner\");\n    state = state_rotate_x(state_rotate_x(state));\n\n    // update position\n    inert_corner_pos = get_position_of_inertial_corner(state);\n  }\n\n  // move inert corner to the FTR spot\n  if (inert_corner_pos == 1)\n    state = state_rotate_y(state_rotate_y(state_rotate_y(state)));\n  else if (inert_corner_pos == 2)\n    state = state_rotate_y(state);\n  else if (inert_corner_pos == 3)\n    state = state_rotate_y(state_rotate_y(state));\n  \n  // it's now in correct pos, but could be facing wrogng way\n  // get orientation and rotate accordingly\n  int inert_corner_orient = get_orientation_of_inertial_corner(state, 0);\n  if(inert_corner_orient == 1)\n    state = state_rotate_x(state_rotate_y(state_rotate_x(state_rotate_y(state))));\n  else if (inert_corner_orient == 2)\n    state = state_rotate_x(state_rotate_y(state));\n  \n  return state;\n}\n\n// Convert normalized scanned state to cpp struct\nskewb_state convert_state_to_struct(const std::string& state)\n{\n  skewb_state new_skewb_state;\n  new_skewb_state.corner_permutations.resize(8);\n\n  // centers\n  // U, F, L, B, R, D\n  new_skewb_state.center_colors.push_back(char_to_center.at(state[0]));\n  new_skewb_state.center_colors.push_back(char_to_center.at(state[5]));\n  new_skewb_state.center_colors.push_back(char_to_center.at(state[20]));\n  new_skewb_state.center_colors.push_back(char_to_center.at(state[15]));\n  new_skewb_state.center_colors.push_back(char_to_center.at(state[10]));\n  new_skewb_state.center_colors.push_back(char_to_center.at(state[25]));\n\n  // corners\n  for (int i = 0; i < 8; ++i)\n  {\n    // indexes map needed due to unconvential order\n    const auto& indices = corners[indexes_map[i]];\n\n    // three colors of the given corner\n    char c1 = state[indices[0]];\n    char c2 = state[indices[1]];\n    char c3 = state[indices[2]];\n\n    // find which piece\n    // order alphabetically and use map\n    std::array<char, 3> chars = {c1, c2, c3};\n    std::sort(chars.begin(), chars.end());\n    std::string color_key = \"\";\n    color_key += chars[0];\n    color_key += chars[1];\n    color_key += chars[2];\n    CORNER piece = colors_to_corner.at(color_key);\n    \n    new_skewb_state.corner_permutations[i] = piece;\n\n    // find orientation\n    // 0 = W/Y on U/D, 1 = W/Y on F/B, 2 = W/Y on L/R\n    for (int j = 0; j < 3; ++j)\n    {\n      char sticker_color = state[indices[j]];\n      if (sticker_color == 'W' || sticker_color == 'Y')\n        new_skewb_state.corner_orientations[piece] = j;\n    }\n  }\n\n  return new_skewb_state;\n}\n\nstd::string center_to_string(CENTER c) {\n  switch (c)\n  {\n    case W: return \"W\";\n    case G: return \"G\";\n    case O: return \"O\";\n    case B: return \"B\";\n    case R: return \"R\";\n    case Y: return \"Y\";\n  }\n  return \"?\";\n}\n\nstd::string corner_to_string(CORNER c)\n{\n  switch (c)\n  {\n      case UFR: return \"UFR\";\n      case UFL: return \"UFL\";\n      case UBL: return \"UBL\";\n      case UBR: return \"UBR\";\n      case DFR: return \"DFR\";\n      case DFL: return \"DFL\";\n      case DBL: return \"DBL\";\n      case DBR: return \"DBR\";\n  }\n  return \"?\";\n}\n\nstd::string skewb_state_to_string(const skewb_state& state)\n{\n  std::string state_key = \"\";\n\n  // centers\n  for (int i = 0; i < state.center_colors.size(); i++)\n  {\n    state_key += center_to_string(state.center_colors[i]);\n  }\n\n  state_key += \" \";\n\n  // permutations\n  for (int i = 0; i < state.corner_permutations.size(); i++)\n  {\n    state_key += corner_to_string(state.corner_permutations[i]) + \" \";\n  }\n\n  state_key += \" \";\n\n  // orientations\n  for (int i = 0; i < state.corner_permutations.size(); i++)\n  {\n    CORNER piece_at_position_i = state.corner_permutations[i];\n    state_key += std::to_string(state.corner_orientations.at(piece_at_position_i));\n  }\n\n  return state_key;\n}\n","textLanguage":"cpp","robotConfig":[],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":""}}