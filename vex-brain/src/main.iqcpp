{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <array>\n#include <algorithm>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       Andrii Bessarab                                              \n//    Created:      Nov. 4, 2025                                                    \n//    Description:  Gets info from. web server, finds appropriate solution on SD card file, and controls robot.\n//                                                                            \n//----------------------------------------------------------------------------\n\n#include \"iq_cpp.h\"\n\nusing namespace vex;\n\n// --- Skewb State Representation ---\nenum CENTER { W, G, O, B, R, Y };\nenum CORNER { UFL, UBL, UBR, UFR, DFL, DBL, DBR, DFR };\nstruct skewb_state\n{\n  std::vector<CENTER> center_colors;\n  std::vector<CORNER> corner_permutations;\n  std::unordered_map<CORNER, int> corner_orientations;\n};\n\n// --- Constants ---\nconst int MAX_BUFFER_SIZE = 100; \nconst std::vector<std::array<int, 3>> corners = {\n  {3, 7, 11},    // 0: UFR\n  {4, 6, 22},    // 1: UFL\n  {2, 16, 12},   // 2: UBR\n  {1, 17, 21},   // 3: UBL\n  {27, 8, 14},   // 4: DFR\n  {26, 9, 23},   // 5: DFL\n  {28, 19, 13},  // 6: DBR\n  {29, 18, 24}   // 7: DBL\n};\n\n// --- Function Prototypes ---\nstd::string get_state_from_serial();\nstd::string normalize_state(std::string state);\n\n// --- Main Function ---\nint main()\n{\n  // Initializing Robot Configuration\n  vexcodeInit();\n\n  // Print waiting for state message\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n  Brain.Screen.print(\"Awaiting state...\");\n\n  // Get skewb state from serial\n  std::string raw_state = get_state_from_serial();\n  std::string normalized_state = normalize_state(raw_state);\n  const char* state = normalized_state.c_str();  // store as c string\n\n  // Print out the state\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(2, 1);\n  Brain.Screen.print(\"%s\", state);\n\n  // Wait before ending program\n  wait(20, seconds);\n\n  // End the program\n  Brain.programStop();\n}\n\n// --- Functions ---\n// Get skewb state from serial\nstd::string get_state_from_serial()\n{\n  char buffer[MAX_BUFFER_SIZE];\n\n  while (true)\n  {\n    if (fgets(buffer, MAX_BUFFER_SIZE, stdin) != NULL)\n    {\n      buffer[strcspn(buffer, \"\\n\\r\")] = '\\0';\n      if (strlen(buffer) > 0)\n        return std::string(buffer);\n    }\n    wait(20, msec);\n  }\n}\n\n// Find pos. of WGR corner on scanned config\nint get_position_of_inertial_corner(const std::string& state)\n{\n  // Index = (FaceIndex * 5) + StickerIndex\n  // Faces: U=0, F=1, R=2, B=3, L=4, D=5\n  // Stickers: C=0, TL=1, TR=2, BR=3, BL=4\n\n  // Check all 8 corners\n  for (int i = 0; i < corners.size(); ++i)\n  {\n    // Sort them alphabetically and check if\n    // the corner has all three colours.\n    const std::array<int, 3>& corner_indices = corners[i];\n\n    // Access the std::string using the [] operator, \n    // which works just like accessing a char array.\n    char c1 = state[corner_indices[0]];\n    char c2 = state[corner_indices[1]];\n    char c3 = state[corner_indices[2]];\n\n    std::array<char, 3> chars = {c1, c2, c3};\n    std::sort(chars.begin(), chars.end());\n\n    if (chars[0] == 'G' && chars[1] == 'R' && chars[2] == 'W')\n      return i;\n  }\n\n  return -1;\n}\n\nint get_orientation_of_inertial_corner(const std::string& state, int pos)\n{\n  // 1 - Up, -1 - Down, 2 - Front, -2 Back, 3 - Right, -3 - Left\n\n  const std::array<int, 3>& indices = corners[pos];\n\n  // Check which of the 3 stickers is W\n  if (state[indices[0]] == 'W')\n  {\n    if (indices[0] > 25)\n      return -1; // Down\n    else\n      return 1;  // Up\n  }\n  else if (state[indices[1]] == 'W')\n  {\n    if (indices[1] > 15)\n      return -2; // Back\n    else\n      return 2;  // Front\n  }\n  else\n  {\n    if (indices[2] > 20)\n      return -3; // Left\n    else\n      return 3;  // Right\n  }\n}\n\nstd::string normalize_state(std::string state)\n{\n  // Figure out pos and orient. of inertial corner in scanned position\n  int inert_corner_pos = get_position_of_inertial_corner(state);\n  int inert_corner_orient = get_orientation_of_inertial_corner(state, inert_corner_pos);\n\n  // Normalize cube\n  // Put inert corner at TFR with white facing up\n  // TODO\n\n  return std::to_string(inert_corner_orient);\n}\n","textLanguage":"cpp","robotConfig":[],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":""}}